<!--suppress XmlInvalidNamespace -->
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8"/>
    <title>Available Orders</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <link rel="stylesheet" th:href="@{/style.css}"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
</head>
<body>

<div class="header">
    <h1>New Orders</h1>
    <div style="position: relative; display:block; top: 10px; text-align:center;">
        <button class="btn btn-additional" onclick="goToHistory()">order history</button>
        <button class="btn btn-additional" onclick="goToActives()">to active ‚Üí</button>
    </div>
</div>

<div class="orders-container" id="available-orders-list">
    <div class="loading">No orders yet...</div>
</div>

<script>
	// Configuration
    const HEARTBEAT_INTERVAL = 30000;
    let heartbeatTimer = null;
    
    const ORDERS_POLL_INTERVAL = 5000; // Update every 5 sec
    let ordersPollTimer = null;
    
    let lastOrdersTouch = "";

    const initData = Telegram.WebApp?.initData || Telegram.WebApp?.initDataUnsafe || '';
    const ordersList = document.getElementById('available-orders-list');

    if (!initData) {
        alert('Telegram initData is missing');
    }
    
 	// --- Driver Presence (Heartbeat) ---
    /**
     * Driver is online and looking at the orders list.
     */
    async function sendHeartbeat() {
        try {
            await fetch('/api/drivers/heartbeat', {
                method: 'POST',
                headers: {
                    'X-Telegram-Init-Data': initData
                }
            });
        } catch (error) {
            console.error('Heartbeat error:', error);
            stopHeartbeat();
        }
    }

    function startHeartbeat() {
        if (heartbeatTimer) return;
        sendHeartbeat();
        heartbeatTimer = setInterval(sendHeartbeat, HEARTBEAT_INTERVAL);
    }

    function stopHeartbeat() {
        clearInterval(heartbeatTimer);
        heartbeatTimer = null;
    }

    function formatDate(datetime) {
        const options = {
            day: '2-digit',
            month: 'long',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        };
        return new Date(datetime).toLocaleString('en-EN', options);
    }
    
 	// --- Order Management ---
    /**
     * Fetches all orders with status 'PENDING' from the server.
     */
    async function loadAvailableOrders() {
        try {
            const response = await fetch('/api/orders', {
                method: 'GET',
                headers: {
                    'X-Telegram-Init-Data': initData
                }
            });

            if (!response.ok) throw new Error('Failed to load orders');

            const orders = await response.json();
            
            const currentTouch = orders.map(o => o.id + o.status).join('|');
            
            if (currentTouch === lastOrdersTouch) {
                return;
            }
            
            lastOrdersTouch = currentTouch;
            renderOrders(orders);
        } catch (err) {
            console.error('Load available orders error:', err);
            if (!ordersList.innerHTML || ordersList.querySelector('.loading')) {
                ordersList.innerHTML = '<div class="error">Error loading orders. Please try again.</div>';
            }
            lastOrdersTouch = "";
        }
    }

    function renderOrders(orders) {
    	if (!ordersList) return;
        ordersList.innerHTML = '';

        if (orders.length === 0) {
            ordersList.innerHTML = '<div class="empty">No orders yet...</div>';
            return;
        }

        orders.forEach(order => {
            const card = document.createElement('div');
            card.className = 'order-card';

            const dateFormatted = formatDate(order.createdAt || order.date || Date.now());
            const priceTotal = order.price + (order.bonusFare || 0);

            card.innerHTML = `
            <div class="order-header">
                <span class="order-date">${dateFormatted}</span>
            </div>
            <hr>
            <div class="order-address"><strong>‚è§</strong> ${order.startAddress}</div>
            <div class="order-address"><strong>‚è§</strong> ${order.endAddress}</div>
            ${order.notes ? `<div class="order-notes">üìå ${order.notes}</div>` : ''}
            <div class="order-price">
                <strong>Total:</strong> ${priceTotal} 
                ${order.bonusFare ? `<span class="bonus">(incl. tip: ${order.bonusFare})</span>` : ''}
            </div>
            <button class="btn btn-blue" data-order-id="${order.id}">Accept</button>
        `;

            card.querySelector('button').addEventListener('click', () => acceptOrder(order.id));
            ordersList.appendChild(card);
        });
    }

    async function acceptOrder(orderId) {
    	Telegram.WebApp.showConfirm('Are you sure you want to accept this order?', async (isConfirmed) => {
        
    	if (!isConfirmed) return;
    	
        try {
            const response = await fetch(`/api/orders/${orderId}`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Telegram-Init-Data': initData
                },
                body: JSON.stringify({action: 'ACCEPT'})
            });

            if (!response.ok) {
                const errorText = await response.text();
                Telegram.WebApp.showAlert('Could not accept order: ' + errorText);
                return;
            }
            
         	// Haptic feedback for successful interaction
            if (Telegram.WebApp.HapticFeedback) {
                Telegram.WebApp.HapticFeedback.notificationOccurred('success');
            }
			
            window.location.href = `/driver/active-order?initData=${encodeURIComponent(initData)}`;
        } catch (err) {
        	Telegram.WebApp.showAlert('Network error. Check your connection.');
        }
    });
    }

 	// --- Navigation ---
    function goToActives() {
        window.location.href = `/driver/active-order?initData=${encodeURIComponent(initData)}`;
    }

    function goToHistory() {
        window.location.href = `/driver/orders-history?initData=${encodeURIComponent(initData)}`;
    }
    
    function startOrdersPolling() {
        if (ordersPollTimer) return;
        loadAvailableOrders();
        ordersPollTimer = setInterval(loadAvailableOrders, ORDERS_POLL_INTERVAL);
    }

    function stopOrdersPolling() {
        clearInterval(ordersPollTimer);
        ordersPollTimer = null;
    }

 	// --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
    	const tg = Telegram.WebApp;
    	tg.ready();

        tg.BackButton.show();
        tg.BackButton.onClick(() => {
            window.location.href = `/index.html?initData=${encodeURIComponent(initData)}`;
        });

        startHeartbeat();
        startOrdersPolling();
    });
 	
 	// --- Activity Monitoring ---
    /**
     * Stops/Starts all timers when the user switches apps or minimizes Telegram.
     */
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            console.log('App hidden: stopping timers');
            stopHeartbeat();
            stopOrdersPolling();
        } else {
            console.log('App visible: resuming timers');
            startHeartbeat();
            startOrdersPolling();
        }
    });
 	
 	
</script>

</body>
</html>
